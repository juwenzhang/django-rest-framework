# drf（二）

> * 对于我们**前后端不分离的开发**的话，就可以应用于后台**管理系统方面**了
> * 对于**前后端不分离的开发**的话，就是应用于我们的**用户系统方面**比较适合了
>   * 对于这种开发模式的话，我们需要进行的就是我们的**根据具体的情况进行具体的分析**
>   * **前后端开发就根据不同的情况进行不同的选择截取**



## 创建纯净项目

> * 首先我们先确定我们的项目存放地方以及虚拟环境的存放地方
>   * 然后就是进行安装我们的所需要的依赖包
>     * **pip install django==version_code**
>     * **pip install djangorestframework**
> * 然后就实现创建我们的项目
>   * **django-admin startproject project_name**
>   * **cd project_name**
> * 最后就是实现我们的创建 django 中的一个一个的 app 应用即可
>   * **python manage.py startapp app_name**
>   * **然后就是实现的是在项目配置文件中修改配置以及其他的应用注册**
>   * **python manage.py runserver** 实现启动项目即可

```python
REST_FRAMEWORK = {
    "UNAUTHENTICATED_USER": None
}
# 配置文件中添加
```

```python
# 总的纯净版的django 项目的配置
"""
Django settings for def_pro project.

Generated by 'django-admin startproject' using Django 3.0.2.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.0/ref/settings/
"""

import os

from rest_framework.settings import api_settings

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'lddtp4h_z1e@t&d!a4u&n2p))y(wbn7=eb#30fdopjre-ayqy9'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    # 'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    # 'django.contrib.sessions',
    # 'django.contrib.messages',
    'django.contrib.staticfiles',
    "app01",
    "api",
    "rest_framework"
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    # 'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    # 'django.contrib.auth.middleware.AuthenticationMiddleware',
    # 'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'def_pro.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                # 'django.contrib.auth.context_processors.auth',
                # 'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'def_pro.wsgi.application'


# Database
# https://docs.djangoproject.com/en/3.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}


# Password validation
# https://docs.djangoproject.com/en/3.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/3.0/topics/i18n/

LANGUAGE_CODE = 'zh-Hans'

TIME_ZONE = 'Asia/ShangHai'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.0/howto/static-files/

STATIC_URL = '/static/'

REST_FRAMEWORK = {
    "UNAUTHENTICATED_USER": None
}
```



## drf 中的 request 对象

* **drf** 中的 **request** 对象对我们的 **django 的 request** 的对象进行了进一步的封装了的
  * 关于 **oop** 面向对象的进一步的探究
    * 就是实现的是使用我们的 class 来实现定义我们的类的
    * 每一个类中含有**成员属性和成员方法**
    * 这是所有的 **oop** 编程语言公用的套路： **javascript | python | C++ | java | C#**
    * 同时在类中**具备我们的反射来实现类中方法的调用**
      * 在类中的 **getattr** 映射通过使用我们的对象来访问我们的**对象中不存在的成员的时候**就会触发调用
        * 主要是针对的是对象中不存在的成员
      * **getattribute**
        * 只要通过对象来实现获取类中的某个属性就会触发类中的该方法，如果属性不存在直接报错

```python
# 下面的代码就是我们的 drf 对原本的 django request进行的封装的原理核心代码思想
class Obj01:
    def get(self):
        print("我是 get 请求")
        
    def post(self):
        print("我是 post 请求")
        
class Obj:
    def __init__(self):
        self._obj01 = Obj01()
        self.data = 10
    
    def __getattr__(self, attr):
        try:
            return getattr(self._obj01, attr)
        except AttributeError as e:
            return self.__getattribute__(attr)

obj = Obj()
obj.data  # 实现的就是获取我们的原本的类中具备的属性
obj.get()  # 就是实现的是我们的间接性的调用我们的 Obj01 中的 get 方法了

"""
这个就是我们 drf 对原本的django request对象进行的封装的基本原理了
"""
```

> * 在我们实现请求的时候也是可以通过可选参数或者说其他参数来实现获取参数的呐

* **request.query_params.get(key)** 实现的就是从Url 的查询字符串中获取数据
* **request.META.get(key)** 实现的就是从请求头中实现查询数据
* **request.data.get(key)** 实现的就是从请求体中查询数据



## drf 认证组件

### 认证组件实质

> * 认证组件的实质的话就是通过继承来简单的实现操作的
>
> * 在我们的 APIView 中具有静态属性： **authentication_classes** 来实现后期的指定我们需要使用那些认证组件
>
> * 我们可以在全局 settings.py 中的配置为：
>
>   * 配置文件为什么是字符串的形式配置的，内部的底层是通过我们的映射实现的
>
>   * ```python
>     """
>     	The following policies may be set at either globally, or per-view.
>         renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES
>         parser_classes = api_settings.DEFAULT_PARSER_CLASSES
>         authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES
>         throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES
>         permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES
>         content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS
>         metadata_class = api_settings.DEFAULT_METADATA_CLASS
>         versioning_class = api_settings.DEFAULT_VERSIONING_CLASS
>     """
>     ```

* 源码上的处理效果的话就是本质上实现了处理我们的每个定义的认证器的对象的
* 源码的核心对象就是： request类 和 APIView类
* 最后实现运行的是我们的每个认证类中的 **authenticate** 方法
  * 在拥有多个认证类的时候，我们的实现效果就是：=只要最终返回的是 None ，那么就进入下一个认证类进行校验
  * 直到返回真真的结果为止



### BaseAuthentication 认证组件

> * **from rest_framework.authentication import BaseAuthentication**

* 主要就是用来实现的是用户登录校验的一个模块
  * 就是在我们的一些 API 中一定需要登录或者满足其他需求后才可以实现最终的使用对应的 API 的
  * 所以说这个的就是我们的认证功能，通过该认证从而实现最终的通过凭证获取对应的信息授权
  * 最常见的模式就是实现使用我们的 **token** 作为校验的准则来实现的
* 认证组件的实现就是通过首先现编写一个类出来，一个类就是我们的认证组件了
  * 然后实现应用我们的认证组件就是我们的实现步骤了
  * 同时也是支持全局配置的

```python
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed

# 开始实现书写我们的一个类来作为我们的登录验证的
class Base_Authentication(BaseAuthentication):
    def authenticate(self, request):
        # 获取永固认证
        # 读取传递过来的 token
        # 检验 token 是否合法
        # 共有三种返回值
            # 返回元组  request.user  request.auth
            # 抛出异常: 实现我们的返回错误信息
            # 返回None  最后就是实现的是使用匿名用户
        # token = request._request.GET("token")
        token = request.query_params.get("token")
        if token:
            return "juwenzhang", token  # 这两个值分贝是赋值给了我们的 request.user 和 request.auth
            # 所以说在后面的视图函数中我们就可以实现的是来获取这两个属性来做一些事情了
        raise AuthenticationFailed({
            "status": False,
            "message": "认证失败"
        })

    def authenticate_header(self, request):
        return "TOKEN"
```

```python
REST_FRAMEWORK = {
    # "UNAUTHENTICATED_USER": None,
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "_authentication.base_authentication.Base_Authentication",
    ]
}
```

```python
from rest_framework.response import Response
from rest_framework.views import APIView
from _authentication.base_authentication import Base_Authentication

'''
每一个视图函数可以实现书写的认证方式可以为多个或者没有
没有的话就是不用进行任何校验
'''

"""
同时我们还是可以通过我们的全局配置来实现最终的确定我们的那些组件需要认证关系
"""

class LoginView(APIView):
    # 通过定义静态变量的形式实现用户校验
    authentication_classes = []
    def get(self, request):
        return Response({
            "message": "欢迎来到 django-rest-framework project"
        })


class UserView(APIView):
    # 通过定义静态变量的形式实现用户校验
    # authentication_classes = [Base_Authentication]
    def get(self, request):
        return Response({
            "message": "欢迎来到 django-rest-framework project",
            "username": "",
            "token": request.auth,
        })


class OrderView(APIView):
    # 通过定义静态变量的形式实现用户校验
    # authentication_classes = [Base_Authentication]
    def get(self, request):
        return Response({
            "message": "欢迎来到 django-rest-framework project",
            "username": "",
            "token": request.auth,
        })


class DefaultView(APIView):
    def get(self, request, *args, **kwargs):
        print(self.args, self.kwargs)
        return Response({
            "message": "欢迎来到 django-rest-framework project"
        })
```

### 源代码阅读技巧

```python
    def authenticate(self, request):
        """
        Authenticate the request and return a two-tuple of (user, token).
        """
        raise NotImplementedError(".authenticate() must be overridden.")
```

> * 如果我们在源码中看到了返回的错误异常是： 
>   * **`raise NotImplementedError(".authenticate() must be overridden.")`**
>   * 那就说明了子类被父类潜规则了，在子类进行继承使用父类的时候，必须将对应方法进行重写

### django 内置的认证组件含有

> * 其他的内置组件都是基于我们的 **BaseAuthentication** 进行认证操作的
>   * **BasicAuthentication**
>   * **SessionAuthentication**
>   * **TokenAuthentication**
>   * **RemoteUserAuthentication**



## drf 权限组件

> * 其使用和认证组件一摸一样的
> * 内部的设计思想的话和我们的认证组件的设计思想一摸一样的，没有很大的区别所在的
> * 也是可以实现的是设置我们的权限的校验的



> * 多个权限组件之间的默认关系
>   * 只有当所有的权限组件为 **True** 的时候才能保证某个用户具备某种权限，就是互相影响的
>   * 但是开发的时候我们是需要进行的是我们的不使用默认情况的



> * 权限组件和我们的认证组件是一样的道理都是具备我们的全局使用和局部使用
> * 全局使用就是在我们的配置文件 settings.py 中进行使用的
> * 局部使用就是在我们的视图函数中进行书写我们的静态属性，从而实现局部的校验即可



> * 同时我们还是可以实现自定义我们的没有权限的信息返回的
> * 这个时候需要进行的就是我们的在全局中进行配置我们的 **message** 信息即可



> * 对于我们的权限管理组件的话，djangorestframework 的底层实现只要是一个不通过，直接就不通过，直接 pass 了
> * 所以说我们这个时候为了满足其他的条件需求，这个时候就需要进行的是对方法进行重写即可
> * **check_permission** 方法的重写，从而实现我们的源码的扩展修改流程即可



> * 在我们的权限组件中，如果我们实现返回的是 True ，表示的就是实现了最终的有权限
> * 如果权限组件返回的是 False ，就是实现的是我们的当前用户没有权限



> * 但是在我们的拥有多个权限认证组件的时候，我们就需要进行的是我们的对视图源码进行重写
> * 因为源码的话实现的是我们的只要含有一个权限组件失败了，最终的效果就是直接全部权限没有了



```python
from rest_framework.views import APIView

class ProAPIView(APIView):
    def check_permissions(self, request):
        not_have_permission_objects = []
        for _permission in self.get_permissions():
            if _permission.has_permission(request, self):
                return
            else:
                not_have_permission_objects.append(_permission)

        if len(not_have_permission_objects) > 0:
            self.permission_denied(
                request,
                message=getattr(not_have_permission_objects[0], "message", None),
                code=getattr(not_have_permission_objects[0], "code", None)
            )
```





## drf 限流组件

* 该功能就是实现我们的限制某个接口不被用户访问的过于频繁了
  * 这个时候就可以通过我们的限流实现该功能，相当于前端的节流吧
  * 实现该功能的实质就是通过寻找唯一标识实现的限制
* 实现限流的基本流程就是：
  * 首先先确定我们的一个条件  10min
  * 然后获取当前时间  16：45
  * 当前时间 - 时间间隔 = 计数开始时间  16: 35
  * 计算时间间隔内的访问次数
    * 超过： 请求超时
    * 未过： 继续可以请求



## 源码分析

**首先需要注意的是我们的源码是分析的是我们的 APIView 视图的源码**

### 内部 initial 函数的源码

```python
    def initial(self, request, *args, **kwargs):
        """
        Runs anything that needs to occur prior to calling the method handler.
        """
        self.format_kwarg = self.get_format_suffix(**kwargs)

        # Perform content negotiation and store the accepted info on the request
        neg = self.perform_content_negotiation(request)
        request.accepted_renderer, request.accepted_media_type = neg

        # Determine the API version, if versioning is in use.
        version, scheme = self.determine_version(request, *args, **kwargs)
        request.version, request.versioning_scheme = version, scheme

        # Ensure that the incoming request is permitted
        self.perform_authentication(request)
        self.check_permissions(request)
        self.check_throttles(request)
```

> * 对于上面的源码的话我们比较重要的分析就是关于最后的三个语句的
>
> * 最后的三个语句就实现了我们的认证组件，权限组件以及节流组件的校验流程
>
>   * 首先执行的是我们的认证组件的对视图的校验流程
>   * 然后等待认证组件的校验通过后，就直接进行我们的权限校验过程
>   * 最后就是实现的是我们的节流校验流程了
>
> * 在我们的认证流程中，我们的实现的话就是肯定是我们的认证组件通过后才是我们的权限校验流程
>
>   * 就可以不用考虑当认证全部失败后的情况了
>
> * ```python
>   def initial(self, request, *args, **kwargs):
>       self.perform_authentication(request)
>       self.check_permissions(request)
>       self.check_throttles(request)
>   ```

### 内部 dispatch 函数的实现

```python
    def dispatch(self, request, *args, **kwargs):
        """
        `.dispatch()` is pretty much the same as Django's regular dispatch,
        but with extra hooks for startup, finalize, and exception handling.
        """
        self.args = args
        self.kwargs = kwargs
        request = self.initialize_request(request, *args, **kwargs)
        self.request = request
        self.headers = self.default_response_headers  # deprecate?

        try:
            self.initial(request, *args, **kwargs)

            # Get the appropriate handler method
            if request.method.lower() in self.http_method_names:
                handler = getattr(self, request.method.lower(),
                                  self.http_method_not_allowed)
            else:
                handler = self.http_method_not_allowed

            response = handler(request, *args, **kwargs)

        except Exception as exc:
            response = self.handle_exception(exc)

        self.response = self.finalize_response(request, response, *args, **kwargs)
        return self.response
```

